#  Flutter 2.0+ 默认启用了空安全
空安全 会在编译期防止意外访问 null 变量的错误的产生。

我们在定义 Widget 和 Model 时 `?.、!、late` 会大量应用。

## 一、自定义Widget的空安全适配

### Widget的空安全适配

1. 可空的属性：通过?进行修饰
2. 不可空的属性：在构造函数中设置默认值或者通过required进行修饰

```dart
import 'package:flutter/material.dart';

class CustomCard extends StatelessWidget {
  // 1. 可空的属性，可能为 null，调用方可以不传
  final String? subtitle;

  // 2. 在构造函数中设置默认值的不可空属性
  final Color backgroundColor;
  final bool showShadow;

  // 3. 没有默认值的不可空属性
  final String title;

  // 4. 其它属性（例如回调、复杂对象等）
  final VoidCallback? onTap; // 可空的回调
  final EdgeInsets padding; // 不可空，但有默认值

  // 构造函数：使用命名参数 + required 标记必填项
  const CustomCard({
    super.key,
    required this.title,                // 3. 必填不可空
    this.subtitle,                      // 1. 可空
    this.backgroundColor = Colors.white, // 2. 默认值（不可空）
    this.showShadow = false,            // 2. 默认值（不可空）
    this.onTap,                         // 4. 可空回调
    this.padding = const EdgeInsets.all(16.0), // 4. 默认值的其它属性
  });

  @override
  Widget build(BuildContext context) {
    return GestureDetector(
      onTap: onTap,
      child: Card(
        color: backgroundColor,
        elevation: showShadow ? 4.0 : 0.0,
        child: Padding(
          padding: padding,
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Text(
                title,
                style: const TextStyle(fontWeight: FontWeight.bold, fontSize: 18),
              ),
              if (subtitle != null) // 安全检查可空属性
                Text(
                  subtitle!,
                  style: const TextStyle(color: Colors.grey),
                ),
            ],
          ),
        ),
      ),
    );
  }
}
```

### State的空安全适配
1. 可空的变量：通过?进行修饰
2. 不可空的属性：
  - 定义时初始化；
  - 使用late修饰为延时变量；

```dart
import 'package:flutter/material.dart';

class DataLoaderWidget extends StatefulWidget {
  final String title;

  const DataLoaderWidget({
    super.key,
    required this.title,
  });

  @override
  State<DataLoaderWidget> createState() => _DataLoaderWidgetState();
}

class _DataLoaderWidgetState extends State<DataLoaderWidget> {
  // 1️⃣ 可空的变量：初始为 null，后续可能被赋值
  String? fetchedData; 

  // 2️⃣ 不可空属性：在定义时直接初始化（✅ 推荐）
  int retryCount = 0;
  List<String> logMessages = []; // 初始为空列表，但永不为 null

  // 3️⃣ 不可空属性：使用 late 修饰（⚠️ 需确保在使用前赋值）
  late DateTime loadTime;

  @override
  void initState() {
    super.initState();
    
    // 初始化 late 变量（必须在 build 前赋值！）
    loadTime = DateTime.now();
    
    // 模拟加载数据
    _loadData();
  }

  Future<void> _loadData() async {
    setState(() {
      // 清除旧数据（可空变量设为 null 表示“正在加载”或“未加载”）
      fetchedData = null;
    });

    await Future.delayed(const Duration(seconds: 1));

    // 模拟成功加载
    final data = "成功加载的数据 (尝试第 ${retryCount + 1} 次)";
    
    setState(() {
      fetchedData = data; // 赋值后变为非空
      retryCount++;
      logMessages.add('[$loadTime] $data');
    });
  }

  @override
  Widget build(BuildContext context) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        // 使用可空变量（安全访问）
        Text(
          '数据: ${fetchedData ?? '暂无数据'}',
          style: const TextStyle(fontSize: 16),
        ),

        const SizedBox(height: 12),

        // 使用定义时初始化的不可空属性
        Text('重试次数: $retryCount'),
        Text('日志条数: ${logMessages.length}'),

        const SizedBox(height: 12),

        // 使用 late 变量（已确保在 initState 中初始化）
        Text('首次加载时间: ${loadTime.toIso8601String()}'),

        const SizedBox(height: 20),

        // 操作按钮
        ElevatedButton(
          onPressed: _loadData,
          child: const Text('重新加载'),
        ),

        // 显示日志
        if (logMessages.isNotEmpty) ...[
          const SizedBox(height: 12),
          const Text('加载日志:', style: TextStyle(fontWeight: FontWeight.bold)),
          ...logMessages.map((msg) => Text('- $msg')).toList(),
        ],
      ],
    );
  }
}
```

## 二、数据模型(Model)空安全适配
适配之前首先要和服务端协商好，模型中那些字段可空，那些字段是一定会下发的。
  
  - 不能保证一定会下发的字段，通过 ? 将其修饰为可空的变量；
  - 不可空的字段，在命令基本构造函数中需要用 required 修饰；

```dart
class User {
  final String? name;
  final int age;

  User({ this.name, required this.age });

  // 工厂构造函数：从 JSON Map 构建 User
  factory User.fromJson(Map<String, dynamic> json) {
    return User(
      json['name'] as String,
      json['age'] as int,
    );
  }
}
```