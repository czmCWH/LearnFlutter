# 一、Flutter 状态管理

状态 (State) 管理介绍，<https://docs.flutter.cn/data-and-backend/state-mgmt/options>
路由和状态管理，<https://docs.flutter.cn/community/tutorials>

状态是指 当任何时候你需要重建你的用户界面时你所需要的数据。
如果状态是组件私有的，则应该由组件自己管理；如果状态要跨组件共享，则该状态应该由各个组件共同的父元素来管理。

# Flutter 内置的状态管理方式

1、setState，用于 Widget 临时状态的基础方式。仅限于在单个 Widget 中进行状态管理。

2、InheritedWidget 和 InheritedModel
  -  InheritedWidget 是用于在 Widget tree 中高效地向下传递数据的基类。
  - 作用是：让子树中的多个 widget 能够共享同一份数据，而无需通过层层构造函数参数传递（即“prop drilling”）。
  - InheritedWidget 是 `Provider package` 的底层实现。

3、观察者模式：ValueNotifier 和 InheritedNotifier
  - 一种完全使用 Flutter 提供的 API 来更新状态并通知 UI 更新的方式。
  - 响应式编程，可以跨组件共享状态。


# 跨组件共享状态的管理方式

* 观察者模式；

* provider package：用来管理简单的全局应用状态；

* GetX package：一个简单的响应式状态管理解决方案，它还包含智能依赖注入和路由管理；GetX 是一个流行的 Flutter 状态管理和路由导航工具包，它提供了许多功能，包括快速且易于使用的状态管理、依赖注入、路由导航、国际化、主题管理等。是由社区开发和维护的第三方工具包。


## provider package
<https://docs.flutter.cn/data-and-backend/state-mgmt/simple>

Flutter 应用中最传统的状态管理方案是使用有状态 widget 的 setState 的方法，这种方式暴露出来的问题是，大型应用中的 widget 树会非常复杂，
每当状态更新调用 setState 时，则会牵一发而动全身，重建所有子树，使性能大打折扣。

那么，当将 ChangeNotifier 观察者模式应用在状态管理方案中时，便能解决这个问题。
设想让每一个最小组件充当观察者，观察应用的状态，每当状态改变时即驱动该局部小组件更新，是不是就能达到这种目的。
我们常用 provider package 就应用了这个原理。

provider 内部提供了一个 ChangeNotifierProvider widget，可以向其子组件暴露一个 ChangeNotifier 实例 (被观察者) 。
