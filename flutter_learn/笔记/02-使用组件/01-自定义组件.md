# 一、Widget 显示的过程

一个 Flutter 应用本身就是一个 widget，大多数 widget 都有一个 build() 方法，在应用的 build() 方法中实例化和返回一个 widget 会让它显示出来。

widget 的主要工作是实现 build() 函数，该函数用其他较低级别的 widget 来描述 widget。框架依次构建这些 widget，直到生成表示底层 `RenderObject` 的 widget，RenderObject 计算并描述小部件的几何结构。
优化`build`方法的性能以保持流畅的渲染性能非常重要。

> 在编写 App 时，通常会创建新的 widgets，这些 Widgets 是 `StatelessWidget` 或 `Statfulwidget` 的子类，这取决于 widget 是否管理任何状态。

<https://docs.flutter.cn/get-started/fundamentals/widgets>

# 二、StatelessWidget 无状态组件
<https://api.flutter.dev/flutter/widgets/StatelessWidget-class.html>

StatelessWidget 从它们的父 `widget` 接收参数，它们被存储在 `final` 类型的成员变量中。当它被构建时（即调用 build），它使用这些存储的值作为参数来构建 widget。例如：Padding、Text 和 Icon 等。

* 特点：
  - 不包含可变状态，即没有随时间变化的成员属性！

* StatelessWidget 的 build 方法通常只在三种情况下调用：
  - widget 第一次插入树中时；
  - 当 widget的父级改变其配置时；
  - 当它依赖于一个[InheritedWidget](https://api.flutter.dev/flutter/widgets/InheritedWidget-class.html)更改时。


# 二、StatefulWidget 有状态组件
<https://api.flutter-io.cn/flutter/widgets/StatefulWidget-class.html>

StatefulWidget 实例 本身是不可变的，其可变状态存储在由 `createState` 方法创建的单独的 `State` 对象中，或者 存储在该 State 订阅的对象中（如： Stream、ChangeNotificationer），这些对象的引用存储在 StatefulWidget 本身的 final 字段中。

* StatefulWidget 没有 build 方法，它的用户界面是通过关联其 State 对象来构建的。

## StatefulWidget 的 State 对象
State 状态是指：
- 在构建 widget 时可以同步读取的信息；
- 在 widget 的生命周期中可以发生变化的信息；

State 使用 `setState` 方法管理它的状态改变，通过调用 setState 告诉 Flutter 框架，某个状态发生了
变化，Flutter 会重新运行它的 build 方法，以便应用程序可以应用最新状态。

Flutter 框架每次创建 StatefulWidget 时都会调用 createState 方法，这意味着如果同一个 StatefulWidget 被插入到组件树的多个位置，则可能存在多个 State 对象与该组件关联。
同样地，如果从树中移除一个 StatefulWidget，之后又将其插入到树中，框架将再次调用 createState 来创建一个新的 State 对象，从而简化 State 对象的生命周期。


## GlobalKey Widget

带有 GlobalKey 的小部件在树中最多只能在一个位置使用，所以使用 GlobalKey 的 Widget 最多只有一个关联元素。
当将具有 GlobalKey 的 widget 从树中的一个位置移动到另一个位置时，Flutter 框架会利用此特性，将与该小部件关联的（唯一）子树从旧位置嫁接到新位置（而不是在新位置重新创建子树）。

如果 StatefulWidget 的创建者使用 GlobalKey 作为其键，则当 StatefulWidget 从树中的一个位置移动到另一个位置时，它将保持相同的 State 对象（而不是被重新创建）。


## StatefulWidget 的分类

### StatefulWidget 类别一
在 `State.initState` 中分配资源，并在 `State.dispose` 中释放资源，但它不依赖于 `InheritedWidgets` 或调用 `State.setState`。

* 应用场景：
  - 此类 StatefulWidget 通常用于应用程序或页面的根部，并通过 ChangeNotifiers、Streams 或其他此类对象与 子Widget 通信。

* 特点：
  - 遵循这种模式的有状态组件相对来说开销较小（CPU 和 GPU 周期消耗较低），因为它们只需构建一次，之后无需更新。因此，它们的构建方法可以更加复杂和深入。

### StatefulWidget 类别二
使用 `State.setState` 或依赖于 `InheritedWidgets` 的 Widget。

* 特点：
  - 此类型的 StatefulWidget 在APP的生命周期内通常会多次 rebuild 重建，因此尽量减少重建此类组件的影响至关重要。
  - 此类型的 StatefulWidget 也可以使用`State.initState` 或 `State.didChangeDependencies` 并分配资源，但重要的是它们会 rebuild 重建。

* 有如下几种方法可以最大限度地减少 rebuild 重建 StatefulWidget 的对性能的影响：
- 将 state 推到 leaves(子节点) 上。
- 尽量减少 build 方法所创建的节点数以及它所创建的任何 widget。
- 如果子树没有更改，则缓存表示该子树的 widget，并在每次可以使用它时重用它。
- 尽可能使用 const 小部件。(这相当于缓存一个小部件并重用它。)
- 避免更改任何已创建子树的深度或更改子树中任何小部件的类型。
  - 如果由于某种原因必须更改深度，请考虑将子树的公共部分包装在具有 GlobalKey 的 Widget 中，该 widget 在 StatefulWidget 的生命周期内保持致。
  - 当尝试创建可重用的UI时，最好使用 widget 而不是 helper 方法。
