# Dart 类




#### 工厂构造函数

使用 `factory` 关键字标识类的构造函数将会令该构造函数变为工厂构造函数，这将意味着使用该构造函数构造类的实例时 `并非总是` 会返回新的实例对象。

* 工厂构造函数无法访问 `this`。

* 工厂构造函数的使用场景：
例如，工厂构造函数可能从缓存返回一个实例，或者可能返回一个子类型的实例。工厂构造函数的另一个用例 是使用初始化列表中无法处理的逻辑来初始化最终变量。


#### 调用父类非默认构造函数

* 构造函数不被继承

子类不会继承父类的构造函数。 类不声明构造函数，那么它就只有默认构造函数 (没有参数，没有名称) 。


默认情况下，子类中的构造函数会自动调用父类的 `匿名、无参数 的构造函数`，并且该调用会在子类构造函数的函数体代码执行前。如果子类提供了一个`initializer list`(初始化参数列表)，它将在调用父类之前执行。执行顺序如下：

* 初始化参数列表
* 父类的无参数构造函数
* 主类的无参数构造函数

如果父类没有 `匿名、无参数 的构造函数`，则必须手动调用父类中的构造函数之一。 在当前构造函数冒号`:`之后，函数体之前，声明调用父类构造函数。如以下代码：

```Dart
class Animal {
  String? type;
  
  Animal.initStr(String name) {
    type = name;
  }
}

class Monkey extends Animal {
  var name = '';
  
  Monkey(String name): super.initStr('猴子') {
    this.name = name;
  }
}

var mk = Monkey('阿康');
print('${mk.name} ${mk.type}');   // 打印：阿康 猴子
```

#### 初始化列表

除了调用父类构造函数外，还可以在构造函数主体运行之前初始化实例变量。用逗号分隔初始化程序。

```Dart
class Point {
  int? x;
  int? y;
  
  // 注意：初始化程序的右侧无法访问 this 
  Point.fromJSON(Map<String, int> mp)
        : x = mp['x']!, y = mp['y'] {
    print('$x $y');
  }
}

var p1 = Point.fromJSON({"x": 10, "y": 20});
// 打印：10 20
```

* 使用初始化列表可以很方便的设置 `final` 属性

```Dart
class Point {
  final int x;
  final int y;
  int sum = 0;
  
  Point(int x, int y): x = x, y = y, sum = x*y {
    print('$x $y $sum');
  }
}

var p = Point(2, 3);        // 打印：2 3 6
```

使用初始化列表

```Dart
class Person {
  String name;
  int age;
  
  Person(String name, int age): name = name, age = age { }
  
  // 这样会报错，因为使用this之前属性未被初始化
//   Person(String name, int age) {
//     this.name = name;
//     this.age = age;
//   }
}
```






## 泛型

在基本数组类型 `List` 实际上是 `List<E>`。 `<…>` 符号将 `List` 标记为 泛型(`generic`)（或参数化）类型，这种类型具有形式类型参数。通常情况下，使用一个字母来代表类型参数，例如 `E`，`T`，`S`，`K`和`V`。
 
在类型安全上通常需要泛型(`Generics`) 支持，它的好处不仅仅是保证代码的正常运行：

* 正确指定泛型类型可以提高代码质量。
* 使用泛型可以减少重复的代码。

如果打算仅包含字符串的列表，则可以将其声明为`List<String>`，读作 “字符串类型的 list ”。 那么，当一个非字符串被赋值给了这个 list 时，开发工具就能够检测到这样的做法可能存在错误。：

```Dart
var ls = <String>[];
ls.add('xxx');
```

### 使用集合字面量

`List`、`Set` 和 `Map` 字面量也是可以参数化的。参数化字面量和之前的字面量定义类似， 下面是参数化字面量的示例：

```Dart
var ls = <String>['a', 'b', 'c'];
var st = <String>{'a', 'b', 'c'};
var mp = <String, int>{'a': 1, 'b':2};

print('${ls is List<String>} ${st is Set<String>} ${mp is Map<String,int>}');
// 打印：true true true
```

### 使用泛型类型的构造函数

`List<T>` 类型无法使用 `List<String>()` 来创建。

```Dart
//   var ls = List<String>();
var ls = <String>[];

var st = Set<String>();

var mp = Map<String, int>();
```

### 限制泛型类型

使用泛型类型的时候， 可以使用 `extends` 实现参数类型的限制。

```Dart
class Foo<T extends SomeBaseClass> {
  String toString() => "Instance of 'Foo<$T>'";
}

class SomeBaseClass { }
```

 