# Dart 类


## 类的定义

* `obj.runtimeType` 在运行时获取对象的类型

### 实例变量

* 所有未初始化的实例变量的值都为`null`。

* 所有实例变量都会生成一个隐式的`getter`方法。没有初始化器的 `Non-final` 和`late final`实例变量也会生成隐式的`setter`方法。 

* 实例变量可以是`final`。`final`的初始化：可以在声明`non-late`实例变量时、使用构造函数参数、构造函数的初始化列表时初始化：

```Dart
class Point {
  int? x;
  int? y;
  int z = 0;
  final String name = 'point';
}
```

* 使用 `.` 来引用实例对象的变量和方法；
* 使用 `?.` 来代替 `.` ， 可以避免因为左边对象可能为 `null` 导致的异常：

```Dart
Point? p = Point();
print('${p.x}');        // 打印：null

p = null;
print('${p?.z}');   // 打印：null
```






### 构造函数

可以使用构造函数创建对象。构造函数名称可以是`ClassName` 或 `ClassName.identifier`。

* 下面 `this` 表示引用当前实例；
* 仅当名称冲突时才使用 `this`。 否则，Dart样式将忽略 `this`。

```Dart
class Point {
  int? x;
  int? y;
  int z = 0;
  final String name = 'point';
  
  Point(int x, int y, int z) {
    this.x = x;
    this.y = y;
    this.z = z;
  }
  
  // 通过语法糖来简写，与上面构造函数等价
//   Point(this.x, this.y, this.z);
}

var p = Person("czm", 28);
```

* 默认构造函数

如果未声明构造函数，那么 `Dart` 会自动生成一个无参数的构造函数并且该构造函数会调用其父类的无参数构造方法。




#### 常量构造函数

如果你的类产生了永不改变的对象，那么就可以把这些对象定义为`compile-time constants`(编译时常量)。为此，需要定义`const` 构造函数，并确保所有实例变量都是 `final`。 

```Dart
class ConstPoint {
  // 定义常量对象
  static const ConstPoint origin = ConstPoint(0, 0);
  
  final double x, y;
  const ConstPoint(this.x, this.y);
}

print(ConstPoint.origin.x);     // 打印：0

```

使用`const`构造函数时用，`const` 关键字修饰，当传入相同参数时，可以确保创建出来的对象是相同的。

```Dart
var cp1 = const ConstPoint(1.2, 1.3)
var cp2 = const ConstPoint(1.2, 1.3)
print(identical(cp1, cp2)); // true
```

> 常量构造函数创建的实例并不总是常量。

#### 工厂构造函数

使用 `factory` 关键字标识类的构造函数将会令该构造函数变为工厂构造函数，这将意味着使用该构造函数构造类的实例时 `并非总是` 会返回新的实例对象。

* 工厂构造函数无法访问 `this`。

* 工厂构造函数的使用场景：
例如，工厂构造函数可能从缓存返回一个实例，或者可能返回一个子类型的实例。工厂构造函数的另一个用例 是使用初始化列表中无法处理的逻辑来初始化最终变量。


#### 调用父类非默认构造函数

* 构造函数不被继承

子类不会继承父类的构造函数。 类不声明构造函数，那么它就只有默认构造函数 (没有参数，没有名称) 。


默认情况下，子类中的构造函数会自动调用父类的 `匿名、无参数 的构造函数`，并且该调用会在子类构造函数的函数体代码执行前。如果子类提供了一个`initializer list`(初始化参数列表)，它将在调用父类之前执行。执行顺序如下：

* 初始化参数列表
* 父类的无参数构造函数
* 主类的无参数构造函数

如果父类没有 `匿名、无参数 的构造函数`，则必须手动调用父类中的构造函数之一。 在当前构造函数冒号`:`之后，函数体之前，声明调用父类构造函数。如以下代码：

```Dart
class Animal {
  String? type;
  
  Animal.initStr(String name) {
    type = name;
  }
}

class Monkey extends Animal {
  var name = '';
  
  Monkey(String name): super.initStr('猴子') {
    this.name = name;
  }
}

var mk = Monkey('阿康');
print('${mk.name} ${mk.type}');   // 打印：阿康 猴子
```

#### 初始化列表

除了调用父类构造函数外，还可以在构造函数主体运行之前初始化实例变量。用逗号分隔初始化程序。

```Dart
class Point {
  int? x;
  int? y;
  
  // 注意：初始化程序的右侧无法访问 this 
  Point.fromJSON(Map<String, int> mp)
        : x = mp['x']!, y = mp['y'] {
    print('$x $y');
  }
}

var p1 = Point.fromJSON({"x": 10, "y": 20});
// 打印：10 20
```

* 使用初始化列表可以很方便的设置 `final` 属性

```Dart
class Point {
  final int x;
  final int y;
  int sum = 0;
  
  Point(int x, int y): x = x, y = y, sum = x*y {
    print('$x $y $sum');
  }
}

var p = Point(2, 3);        // 打印：2 3 6
```

使用初始化列表

```Dart
class Person {
  String name;
  int age;
  
  Person(String name, int age): name = name, age = age { }
  
  // 这样会报错，因为使用this之前属性未被初始化
//   Person(String name, int age) {
//     this.name = name;
//     this.age = age;
//   }
}
```






## 泛型

在基本数组类型 `List` 实际上是 `List<E>`。 `<…>` 符号将 `List` 标记为 泛型(`generic`)（或参数化）类型，这种类型具有形式类型参数。通常情况下，使用一个字母来代表类型参数，例如 `E`，`T`，`S`，`K`和`V`。
 
在类型安全上通常需要泛型(`Generics`) 支持，它的好处不仅仅是保证代码的正常运行：

* 正确指定泛型类型可以提高代码质量。
* 使用泛型可以减少重复的代码。

如果打算仅包含字符串的列表，则可以将其声明为`List<String>`，读作 “字符串类型的 list ”。 那么，当一个非字符串被赋值给了这个 list 时，开发工具就能够检测到这样的做法可能存在错误。：

```Dart
var ls = <String>[];
ls.add('xxx');
```

### 使用集合字面量

`List`、`Set` 和 `Map` 字面量也是可以参数化的。参数化字面量和之前的字面量定义类似， 下面是参数化字面量的示例：

```Dart
var ls = <String>['a', 'b', 'c'];
var st = <String>{'a', 'b', 'c'};
var mp = <String, int>{'a': 1, 'b':2};

print('${ls is List<String>} ${st is Set<String>} ${mp is Map<String,int>}');
// 打印：true true true
```

### 使用泛型类型的构造函数

`List<T>` 类型无法使用 `List<String>()` 来创建。

```Dart
//   var ls = List<String>();
var ls = <String>[];

var st = Set<String>();

var mp = Map<String, int>();
```

### 限制泛型类型

使用泛型类型的时候， 可以使用 `extends` 实现参数类型的限制。

```Dart
class Foo<T extends SomeBaseClass> {
  String toString() => "Instance of 'Foo<$T>'";
}

class SomeBaseClass { }
```

 